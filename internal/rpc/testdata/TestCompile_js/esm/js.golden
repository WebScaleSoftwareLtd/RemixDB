// This file is automatically generated by RemixDB. Do not edit.

"use strict";

// Defines all of the auto-generated structures.
const _autoGeneratedStructures = {};

// Defines the magical any object to mean this can be any type.
const _any = {};

// Defines the magical object to mean uint or float.
const _uint = {};
const _float = {};

// Validates a type. typeAnnotation can be the _any object, a array
// (either of 1 type to mean array type or multiple meaning a union),
// a object with _key set to an array of [keyType, valueType], or a
// String/Number/Boolean/BigInt/Date/null/struct class type.
function _validateType(value, typeAnnotation) {
  if (typeAnnotation === _any) return;

  // Handle the possibilities for arrays.
  if (Array.isArray(typeAnnotation)) {
    // Handle when it is just an array case.
    if (typeAnnotation.length === 1) {
      if (!Array.isArray(value)) throw new Error("Expected array");
      for (const v of value) _validateType(v, typeAnnotation[0]);
      return;
    }

    // Handle when it is a union case.
    for (const t of typeAnnotation) {
      try {
        _validateType(value, t);
        return;
      } catch (_) {
        // Ignore.
      }
    }
    throw new Error(`Expected one of ${typeAnnotation} to match ${value}`);
  }

  // Handle null.
  if (typeAnnotation === null) {
    if (value !== null) throw new Error("Expected null");
    return;
  }

  // Handle the magic uint/float case.
  if (typeAnnotation === _uint) {
    if (typeof value !== "number") throw new Error("Expected number");
    if (value < 0) throw new Error("Expected positive number");
    if (value !== Math.floor(value)) throw new Error("Expected integer");
    return;
  }
  if (typeAnnotation === _float) {
    if (typeof value !== "number") throw new Error("Expected number");
    return;
  }

  // Handle the object cases.
  let kv;
  try {
    kv = typeAnnotation._key;
  } catch (_) {
    // Ignore.
  }
  if (kv) {
    if (typeof value !== "object") throw new Error("Expected object");
    for (const k in value) {
      _validateType(k, kv[0]);
      _validateType(value[k], kv[1]);
    }
    return;
  }

  // Handle the class case.
  if (typeof typeAnnotation === "function") {
    if (!(value instanceof typeAnnotation)) {
      throw new Error(`Expected ${typeAnnotation.name}, got ${value}`);
    }
    return;
  }
}

function _readUint32Le(bytes, offset) {
  return (
    (bytes[offset] << 0) |
    (bytes[offset + 1] << 8) |
    (bytes[offset + 2] << 16) |
    (bytes[offset + 3] << 24)
  );
}

function _readUint16Le(bytes, offset) {
  return (bytes[offset] << 0) | (bytes[offset + 1] << 8);
}

function _readInt64Le(bytes, offset) {
  const low = _readUint32Le(bytes, offset);
  const high = _readUint32Le(bytes, offset + 4);
  return low | (high << 32);
}

function _readFloat64Le(bytes, offset) {
  const buffer = new ArrayBuffer(8);
  const view = new DataView(buffer);
  for (let i = 0; i < 8; i++) view.setUint8(i, bytes[offset + i]);
  return view.getFloat64(0, true);
}

/**
 * @param {Uint8Array} bytes
 * @param {Boolean} root
 * @returns {any}
 * Parses the bytes into a structure.
 */
function _parseBytes(bytes, root) {
  function readBytes() {
    // If it is the root, return the bytes.
    if (root) return bytes.slice(1);

    // Read the length after the type.
    const length = _readUint32Le(bytes, 1);
    return bytes.slice(5, 5 + length);
  }

  // Get the type.
  const type = bytes[0];
  switch (type) {
    case 0x00:
      return [null, 1];
    case 0x01:
      return [false, 1];
    case 0x02:
      return [true, 1];
    case 0x03:
      return [new Uint8Array(), 1];
    case 0x04:
      return ["", 1];
    case 0x05: {
      const b = readBytes();
      return [b, (root ? 1 : 5) + b.length];
    }
    case 0x06: {
      const b = readBytes();
      return [new TextDecoder().decode(b), (root ? 1 : 5) + b.length];
    }
    case 0x07: {
      const length = _readUint32Le(bytes, 1);
      bytes = bytes.slice(5);
      const result = [];
      let x = 0;
      for (let i = 0; i < length; i++) {
        const [value, length] = _parseBytes(bytes, false);
        result.push(value);
        bytes = bytes.slice(length);
        x += length;
      }
      return [result, x + 5];
    }
    case 0x08: {
      const length = _readUint32Le(bytes, 1);
      bytes = bytes.slice(5);
      const result = {};
      let x = 0;
      for (let i = 0; i < length; i++) {
        const [key, keyLength] = _parseBytes(bytes, false);
        bytes = bytes.slice(keyLength);
        x += keyLength;
        const [value, valueLength] = _parseBytes(bytes, false);
        bytes = bytes.slice(valueLength);
        x += valueLength;
        result[key] = value;
      }
      return [result, x + 5];
    }
    case 0x09: {
      // Get the name length.
      const nameLength = bytes[1];

      // Get the name.
      const name = new TextDecoder().decode(bytes.slice(2, 2 + nameLength));

      // Get the structure.
      const structure = _autoGeneratedStructures[name];
      const x = new structure(bytes);
      if (structure) return [x, 2 + nameLength + x._bytesLength];

      // Skip through the structure.
      let i = 2 + nameLength;
      const itemNameLen = _readUint16Le(bytes, i);
      i += 2 + itemNameLen;
      const itemValueLen = _readUint32Le(bytes, i);
      i += 4 + itemValueLen;

      // Return null.
      return [null, i];
    }
    case 0x0a:
      return [_readInt64Le(bytes, 1), 9];
    case 0x0b:
      return [_readFloat64Le(bytes, 1), 9];
    case 0x0c: {
      const timestamp = _readInt64Le(bytes, 1);
      return [new Date(timestamp), 9];
    }
    case 0x0d: {
      const b = readBytes();
      return [new BigInt(b), (root ? 1 : 5) + b.length];
    }
    // TODO
  }
}

class ServerError extends Error {
  constructor(code, message) {
    super(`${code}: ${message}`);
    this.code = code;
    this.message = message;
  }
}


function _parseExceptionPacket(data) {
  const h = data[0];
  if (h === 0x00 || h === 0x01) {
    // Read the next 2 bytes.
    const length = _readUint16Le(data, 1);
    const totalLen = 3 + length;
    const name = data.slice(3, totalLen);

    // The remaining bytes are the value.
    const value = data.slice(totalLen);

    // If h is 0x00, it is a RemixDB error.
    if (h === 0x00) {
      throw new ServerError(
        new TextDecoder().decode(name),
        new TextDecoder().decode(value)
      );
    }

    // Decode value as JSON.
    const json = new TextDecoder().decode(value);
    const obj = JSON.parse(json);

    // Make sure it is a object.
    if (typeof obj !== "object") {
      throw new Error(`Expected object, got ${obj}`);
    }

    // Check if name is a struct name.
    const struct = _autoGeneratedStructures[name];
    if (struct) throw new struct(obj);
    throw new Error(`Unknown struct ${name}`);
  }
}

class Cursor {
  constructor(ws, type) {
    this._ws = ws;
    this._type = type;

    // Buffer messages and errors.
    this._nextId = 0;
    this._messages = [];
    this._resolvers = new Map();
    this._error = null;
    this._rejectors = new Map();

    // Add the event listeners.
    this._ws.addEventListener("message", (event) => {
      const data = event.data;
      const resolvers = this._resolvers;
      this._resolvers = new Map();
      for (const res of resolvers.values()) res(data);
      if (resolvers.size() === 0) this._messages.push(data);
    });
    this._ws.addEventListener("error", (event) => {
      this._error = event;
      const rejectors = this._rejectors;
      this._rejectors = new Map();
      for (const rej of rejectors.values()) rej(event);
    });
  }

  _waitForMessage() {
    const resId = this._nextId++;
    const rejId = this._nextId++;
    return new Promise((resolve, reject) => {
      if (this._error) return reject(this._error);
      if (this._messages.length > 0) return resolve(this._messages.shift());

      this._resolvers.set(resId, (data) => {
        this._resolvers.delete(resId);
        this._rejectors.delete(rejId);
        resolve(data);
      });

      this._rejectors.set(rejId, (error) => {
        this._resolvers.delete(resId);
        this._rejectors.delete(rejId);
        reject(error);
      });
    });
  }

  async next() {
    // Send 0x01 to get the next value.
    this._ws.send(new Uint8Array([0x01]));

    // Wait for the response.
    const data = await this._waitForMessage();

    // Get the header and make sure it is not an exception.
    const h = data[0];
    _parseExceptionPacket(data);

    // If the data is 0x02, chop off the first byte and parse it.
    if (h === 0x02) {
      const [value, _] = _parseBytes(data.slice(1), true);
      _validateType(value, this._type);
      return { value, done: false };
    }

    // If the data is 0x03, then we are done.
    if (h === 0x03) return { done: true };
  }

  close() {
    this._ws.close();
  }
}

class Client {
  constructor(url, options) {
    if (typeof options !== "object") {
      throw new Error("Expected options to be an object");
    }
    this._url = new URL(url);
    this._options = new TextEncoder().encode(JSON.stringify(options) + "\n");
  }

  async _doNonCursorRequest(method, data, schemaHash, type) {
    // Make the request.
    const urlCopy = new URL(this._url);
    urlCopy.pathname = `/rpc/${encodeURIComponent(method)}`;
    const body = new Uint8Array(this._options.length + data.length);
    body.set(this._options);
    body.set(data, this._options.length);
    const res = await fetch(urlCopy.toString(), {
      method: "POST",
      headers: {
        "X-RemixDB-Schema-Hash": schemaHash,
        "Content-Type": "application/x-remixdb-rpc-mixed",
      },
      body,
    });

    // Make sure X-Is-RemixDB is set.
    const isRemixDB = res.headers.get("X-Is-RemixDB");
    if (isRemixDB !== "true") {
      throw new ServerError(
        "response_is_not_remixdb",
        "The response does not appear to be from RemixDB. Does your reverse proxy let through the X-Is-RemixDB header?"
      );
    }

    // Check if the response is a 204.
    if (res.status === 204) {
      _validateType(null, type);
      return null;
    }

    // Check if the response is a 200.
    if (res.status === 200) {
      // Read the bytes.
      const bytes = await res.arrayBuffer();
      const bytesArray = new Uint8Array(bytes);

      // Parse the bytes.
      const [value] = _parseBytes(bytesArray, true);
      _validateType(value, type);
      return value;
    }

    // Check if X-RemixDB-Exception is set.
    const customException = res.headers.get("X-RemixDB-Exception");
    if (customException) {
      // Check if it is in our list of exceptions.
      const exception = _autoGeneratedStructures[customException];

      // Parse the body.
      const json = await res.json();
      if (typeof json !== "object") {
        throw new Error(`Expected object for exception, got ${json}`);
      }

      // Throw the exception.
      if (exception) throw new exception(json);

      // Throw a generic exception.
      throw new Error(`Unknown exception ${customException}`);
    }

    // Parse the body.
    const json = await res.json();
    if (typeof json !== "object") {
      throw new Error(`Expected object, got ${json}`);
    }

    // Check if code and message is set and is a string.
    const code = json.code;
    const message = json.message;
    if (typeof code === "string" && typeof message === "string") {
      throw new ServerError(code, message);
    }
    throw new Error(`Unknown error ${json}`);
  }

  async _doCursorRequest(method, data, schemaHash, type) {
    // Get the URL.
    const urlCopy = new URL(this._url);
    urlCopy.pathname = "/rpc";

    // Make the request.
    const ws = new WebSocket(urlCopy.toString());
    ws.binaryType = "arraybuffer";

    // Wrap it in a cursor.
    const cursor = new Cursor(ws, type);

    // Send the initialization message.
    let msg = new Uint8Array(
      2 + method.length + 2 + schemaHash.length + data.length
    );

    // First 2 bytes are the method length in little endian.
    msg[0] = method.length & 0xff;
    msg[1] = (method.length >> 8) & 0xff;

    // Now we write the method.
    msg.set(method, 2);

    // Now we write the schema hash length.
    msg[2 + method.length] = schemaHash.length & 0xff;
    msg[3 + method.length] = (schemaHash.length >> 8) & 0xff;

    // Now we write the schema hash.
    msg.set(schemaHash, 4 + method.length);

    // Now we write the data.
    msg.set(data, 4 + method.length + schemaHash.length);

    // Send the message.
    ws.send(msg);

    // Wait for the first message.
    msg = await cursor._waitForMessage();

    // Check if it is 0x02.
    if (msg[0] === 0x02) return cursor;

    // Handle exceptions.
    _parseExceptionPacket(msg);
    throw new Error(`Expected 0x02, got ${msg[0]}`);
  }

// used to test a optional struct output
  StructOptionalOutput() {
    const _body = new Uint8Array(0);
    return this._nonCursorRequest("StructOptionalOutput", _body, "TODO", [OneField, null]);
  }

  // used to test a struct cursor output
  StructCursorOutput() {
    const _body = new Uint8Array(0);
    return this._doCursorRequest("StructCursorOutput", _body, "TODO", [OneField, null]);
  }

  // used to test a void input
  VoidInput() {
    const _body = new Uint8Array(0);
    return this._nonCursorRequest("VoidInput", _body, "TODO", String);
  }

  // used to test a void output
  VoidOutput(VoidOutputInput) {
    _validateType(VoidOutputInput, String);
    const _body = _encode(VoidOutputInput);
    return this._nonCursorRequest("VoidOutput", _body, "TODO", null);
  }

  // used to test all void
  AllVoid() {
    const _body = new Uint8Array(0);
    return this._nonCursorRequest("AllVoid", _body, "TODO", null);
  }

  NoComment(NoCommentInput) {
    _validateType(NoCommentInput, String);
    const _body = _encode(NoCommentInput);
    return this._nonCursorRequest("NoComment", _body, "TODO", String);
  }

  // used to test a cursor
  Cursor() {
    const _body = new Uint8Array(0);
    return this._doCursorRequest("Cursor", _body, "TODO", String);
  }

  // used to test a optional cursor
  OptionalCursor() {
    const _body = new Uint8Array(0);
    return this._doCursorRequest("OptionalCursor", _body, "TODO", [String, null]);
  }

  // used to test a struct output
  StructOutput() {
    const _body = new Uint8Array(0);
    return this._nonCursorRequest("StructOutput", _body, "TODO", OneField);
  }
}

const _exports = {
  ServerError,
  Cursor,
  Client,
  OneField,
  ErrorWithMessageField,
  ErrorWithAllFields,
};

export _exports;
