// This file is automatically generated by RemixDB. Do not edit.

package rpc

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
)

type readJoiner struct {
	index   int
	readers []io.Reader
}

func (r *readJoiner) Read(p []byte) (n int, err error) {
	if r.index >= len(r.readers) {
		return 0, io.EOF
	}

	for {
		// Get the current reader.
		reader := r.readers[r.index]

		// Read from the reader.
		x, err := reader.Read(p[n:])
		n += x
		if err == io.EOF {
			// If the reader is done, move to the next one.
			r.index++
			if r.index >= len(r.readers) {
				return n, io.EOF
			}
			continue
		}

		// If all the bytes were read or there was an error, return.
		if n == len(p) || err != nil {
			return n, err
		}

		// If the reader didn't return an error, but didn't read all the bytes,
		// move to the next reader.
		r.index++
		if r.index >= len(r.readers) {
			// If there are no more readers, return the number of bytes read.
			return n, nil
		}
	}
}

// Cursor is used to define the handler for a database cursor. The cursor logic is automatically
// injected if your schema includes a cursor within it.
type Cursor[T any] struct {
    // Hello world!
}

// ErrorWithAllFields used to test a error with all fields
type ErrorWithAllFields struct {
	// Field used to test a field
	Field string `json:"field"`

	// Field2 used to test a field
	Field2 string `json:"field2"`
}

// Error is used to return the error message.
func (e ErrorWithAllFields) Error() string {
	return "ErrorWithAllFields: " + fmt.Sprint("{", "}")
}

// ErrorWithMessageField used to test a error with a message field
type ErrorWithMessageField struct {
	// Field used to test a field
	Field *string `json:"field"`

	// Message used to test a message field
	Message string `json:"message"`
}

// Error is used to return the error message.
func (e ErrorWithMessageField) Error() string {
	return "ErrorWithMessageField: " + fmt.Sprint(e.Message)
}

// OneField used to test a single field
type OneField struct {
	// Field used to test a field
	Field string `json:"field"`
}

// Client is used to define the interface for the generated client.
type Client interface {
	// SetHTTPClient is used to set the HTTP client used by the RPC client. Please
	// note that the HTTP client must be safe for concurrent use, but this method
	// itself is not safe for concurrent use (so call it before you start using
	// the client).
	SetHTTPClient(client *http.Client)

	// AllVoid used to test all void
	AllVoid(ctx context.Context) error

	// Cursor used to test a cursor
	Cursor(ctx context.Context) (Cursor[string], error)

	NoComment(ctx context.Context, NoCommentInput string) (string, error)

	// VoidInput used to test a void input
	VoidInput(ctx context.Context) (string, error)

	// VoidOutput used to test a void output
	VoidOutput(ctx context.Context, VoidOutputInput string) error
}

// AuthenticationOptions is used to define the authentication options for the generated client.
type AuthenticationOptions struct {
	LongKey string `json:"long_key"`
	Key2    string `json:"key2"`
}

type client struct {
	authLine []byte
	url      string
	http     *http.Client
}

// ErrInvalidURLScheme is used when the URL scheme is not supported.
var ErrInvalidURLScheme = fmt.Errorf("invalid URL scheme")

// NewClient is used to create a new client.
func NewClient(urlString string, auth AuthenticationOptions) (Client, error) {
	u, err := url.Parse(urlString)
	if err != nil {
		return nil, err
	}

	if u.Scheme != "http" && u.Scheme != "https" {
		return nil, ErrInvalidURLScheme
	}

	b, _ := json.Marshal(auth)
	return &client{
		authLine: append(b, '\n'),
		url:      urlString,
	}, nil
}

func (c *client) SetHTTPClient(client *http.Client) {
	c.http = client
}

// ServerError is used to represent a server error.
type ServerError struct {
	// StatusCode is the HTTP status code.
	StatusCode int `json:"status_code"`

	// Code is the error code.
	Code string `json:"code"`

	// Message is the error message.
	Message string `json:"message"`
}

// Error is used to return the error message.
func (e ServerError) Error() string {
	return e.Code + ": " + e.Message
}

type httpSwitching struct {
	resp *http.Response
}

func (h httpSwitching) Read(p []byte) (n int, err error) {
	return 0, io.EOF
}

type serverError struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

func (c *client) do(
	ctx context.Context, methodName, schemaHash string,
	input []byte,
) (io.Reader, error) {
	u, err := url.Parse(c.url)
	if err != nil {
		return nil, err
	}
	u.Path = path.Join(u.Path, "rpc", methodName)

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, u.String(), &readJoiner{
		readers: []io.Reader{
			bytes.NewReader(c.authLine),
			bytes.NewReader(input),
		},
	})
	if err != nil {
		return nil, err
	}
	req.Header.Set("X-RemixDB-Schema-Hash", schemaHash)
	req.Header.Set("X-RemixDB-Websocket-Reconnect", "false")
	req.Header.Set("Content-Type", "application/remixdb-rpc-mixed")

	httpClient := c.http
	if httpClient == nil {
		httpClient = http.DefaultClient
	}
	resp, err := httpClient.Do(req)
	if err != nil {
		return nil, err
	}

	if resp.Header.Get("X-Is-RemixDB") != "true" {
		_ = resp.Body.Close()
		return nil, ServerError{
			StatusCode: resp.StatusCode,
			Code:       "response_is_not_remixdb",
			Message:    "The response does not appear to be from RemixDB. Does your reverse proxy let through the X-Is-RemixDB header?",
		}
	}

	switch resp.StatusCode {
	case http.StatusOK:
		return resp.Body, nil
	case http.StatusSwitchingProtocols:
		return httpSwitching{resp: resp}, nil
	}

	switch resp.Header.Get("X-RemixDB-Exception") {
	case "":
		// Do nothing.
	case "ErrorWithAllFields":
		var e ErrorWithAllFields
		defer resp.Body.Close()
		if err := json.NewDecoder(resp.Body).Decode(&e); err != nil {
			return nil, ServerError{
				StatusCode: resp.StatusCode,
				Code:       "invalid_response",
				Message:    "The response could not be decoded.",
			}
		}
		return nil, e
	case "ErrorWithMessageField":
		var e ErrorWithMessageField
		defer resp.Body.Close()
		if err := json.NewDecoder(resp.Body).Decode(&e); err != nil {
			return nil, ServerError{
				StatusCode: resp.StatusCode,
				Code:       "invalid_response",
				Message:    "The response could not be decoded.",
			}
		}
		return nil, e
	default:
		_ = resp.Body.Close()
		return nil, ServerError{
			StatusCode: resp.StatusCode,
			Code:       "exception_not_supported",
			Message:    "The server returned an exception, but this client does not support the exception specified.",
		}
	}

	var e serverError
	defer resp.Body.Close()
	if err := json.NewDecoder(resp.Body).Decode(&e); err != nil {
		return nil, ServerError{
			StatusCode: resp.StatusCode,
			Code:       "invalid_response",
			Message:    "The response could not be decoded.",
		}
	}

	return nil, ServerError{
		StatusCode: resp.StatusCode,
		Code:       e.Code,
		Message:    e.Message,
	}
}

func (c *client) AllVoid(ctx context.Context) error {
    // Hello World!
}

func (c *client) Cursor(ctx context.Context) (Cursor[string], error) {
    // Hello World!
}

func (c *client) NoComment(ctx context.Context, NoCommentInput string) (string, error) {
    // Hello World!
}

func (c *client) VoidInput(ctx context.Context) (string, error) {
    // Hello World!
}

func (c *client) VoidOutput(ctx context.Context, VoidOutputInput string) error {
    // Hello World!
}
