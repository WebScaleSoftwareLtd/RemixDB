// This file is automatically generated by RemixDB. Do not edit.

package {{ Variable "package" }}

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"{{ if HasBigInt . }}
	"math/big"{{ end }}
	"net/http"
	"net/url"
	"path"{{ if HasTime . }}
	"time"{{ end }}{{ if HasCursor . }}

	"nhooyr.io/websocket"{{ end }}
)

type readJoiner struct {
	index   int
	readers []io.Reader
}

func (r *readJoiner) Read(p []byte) (n int, err error) {
	if r.index >= len(r.readers) {
		return 0, io.EOF
	}

	for {
		// Get the current reader.
		reader := r.readers[r.index]

		// Read from the reader.
		x, err := reader.Read(p[n:])
		n += x
		if err == io.EOF {
			// If the reader is done, move to the next one.
			r.index++
			if r.index >= len(r.readers) {
				return n, io.EOF
			}
			continue
		}

		// If all the bytes were read or there was an error, return.
		if n == len(p) || err != nil {
			return n, err
		}

		// If the reader didn't return an error, but didn't read all the bytes,
		// move to the next reader.
		r.index++
		if r.index >= len(r.readers) {
			// If there are no more readers, return the number of bytes read.
			return n, nil
		}
	}
}

{{ range $key, $value := .Structs }}{{ if ne $value.Comment "" }}{{ range $i, $line := SplitLines $value.Comment }}// {{ if eq $i 0 }}{{ TitleCase $key }} {{ end }}{{ $line }}
{{ end }}{{ end }}type {{ TitleCase $key }} struct{{ if ne (len .Fields) 0 }} {{ end }}{{ `{` }}{{ Subtemplate "golang.struct_fields" $value }}}

{{ if $value.Exception }}// Error is used to return the error message.
func (e {{ TitleCase $key }}) Error() string {
{{ if HasKey $value.Fields "message" }}	return "{{ $key }}: " + fmt.Sprint(e.Message)
{{ else }}	return "{{ $key }}: " + {{ Subtemplate "golang.generic_error" $value.Fields }}
{{ end }}}

{{ end }}{{ end }}// Client is used to define the interface for the generated client.
type Client interface {
	// SetHTTPClient is used to set the HTTP client used by the RPC client. Please
	// note that the HTTP client must be safe for concurrent use, but this method
	// itself is not safe for concurrent use (so call it before you start using
	// the client).
	SetHTTPClient(client *http.Client){{ range $key, $value := .Methods }}

{{ if ne $value.Comment "" }}{{ range $i, $line := SplitLines $value.Comment }}	// {{ if eq $i 0 }}{{ TitleCase $key }} {{ end }}{{ $line }}
{{ end }}{{ end }}	{{ TitleCase $key }}{{ Subtemplate "golang.method_sig" $value }}{{ end }}
}

// AuthenticationOptions is used to define the authentication options for the generated client.
type AuthenticationOptions struct {
{{ $keys := .AuthenticationKeys }}{{ range $v := $keys }}	{{ TitleCase $v }}{{ PadToMax $keys $v }}string `json:"{{ $v }}"`
{{ end }}}

type client struct {
	authLine []byte
	url      string
	http     *http.Client
}

// ErrInvalidURLScheme is used when the URL scheme is not supported.
var ErrInvalidURLScheme = fmt.Errorf("invalid URL scheme")

// NewClient is used to create a new client.
func NewClient(urlString string, auth AuthenticationOptions) (Client, error) {
	u, err := url.Parse(urlString)
	if err != nil {
		return nil, err
	}

	if u.Scheme != "http" && u.Scheme != "https" {
		return nil, ErrInvalidURLScheme
	}

	b, _ := json.Marshal(auth)
	return &client{
		authLine: append(b, '\n'),
		url:      urlString,
	}, nil
}

func (c *client) SetHTTPClient(client *http.Client) {
	c.http = client
}

func parseCustomException(key string, body io.Reader) error {
	switch key {
{{ range $key, $value := .Structs }}{{ if $value.Exception }}	case "{{ $key }}":
		var e {{ TitleCase $key }}
		defer resp.Body.Close()
		if err := json.NewDecoder(resp.Body).Decode(&e); err != nil {
			return nil, ServerError{
				StatusCode: resp.StatusCode,
				Code:       "invalid_response",
				Message:    "The response could not be decoded.",
			}
		}
		return nil, e
{{ end }}{{ end }}	}
	return nil
}

// ServerError is used to represent a server error.
type ServerError struct {
	// StatusCode is the HTTP status code. This is not present for cursors.
	StatusCode int `json:"status_code"`

	// Code is the error code.
	Code string `json:"code"`

	// Message is the error message.
	Message string `json:"message"`
}

// Error is used to return the error message.
func (e ServerError) Error() string {
	return e.Code + ": " + e.Message
}{{ if HasCursor . }}

{{ Static "golang.cursor" }}{{ else }}
{{ end }}
type serverError struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

func (c *client) do(ctx context.Context, methodName, schemaHash string, input []byte) (io.Reader, error) {
	u, err := url.Parse(c.url)
	if err != nil {
		return nil, err
	}
	u.Path = path.Join(u.Path, "rpc", methodName)

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, u.String(), &readJoiner{
		readers: []io.Reader{
			bytes.NewReader(c.authLine),
			bytes.NewReader(input),
		},
	})
	if err != nil {
		return nil, err
	}
	req.Header.Set("X-RemixDB-Schema-Hash", schemaHash)
	req.Header.Set("Content-Type", "application/x-remixdb-rpc-mixed")

	httpClient := c.http
	if httpClient == nil {
		httpClient = http.DefaultClient
	}
	resp, err := httpClient.Do(req)
	if err != nil {
		return nil, err
	}

	if resp.Header.Get("X-Is-RemixDB") != "true" {
		_ = resp.Body.Close()
		return nil, ServerError{
			StatusCode: resp.StatusCode,
			Code:       "response_is_not_remixdb",
			Message:    "The response does not appear to be from RemixDB. Does your reverse proxy let through the X-Is-RemixDB header?",
		}
	}

	switch resp.StatusCode {
	case http.StatusOK, http.StatusNoContent:
		return resp.Body, nil
	}

	switch e := resp.Header.Get("X-RemixDB-Exception") {
	case "":
		// Do nothing.
	default:
		if err := parseCustomException(e, resp.Body); err != nil {
			return nil, err
		}
		_ = resp.Body.Close()
		return nil, ServerError{
			StatusCode: resp.StatusCode,
			Code:       "exception_not_supported",
			Message:    "The server returned an exception, but this client does not support the exception specified.",
		}
	}

	var e serverError
	defer resp.Body.Close()
	if err := json.NewDecoder(resp.Body).Decode(&e); err != nil {
		return nil, ServerError{
			StatusCode: resp.StatusCode,
			Code:       "invalid_response",
			Message:    "The response could not be decoded.",
		}
	}

	return nil, ServerError{
		StatusCode: resp.StatusCode,
		Code:       e.Code,
		Message:    e.Message,
	}
}{{ range $key, $value := .Methods }}

func (c *client) {{ TitleCase $key }}{{ Subtemplate "golang.method_sig" $value }} {
{{ Subtemplate "golang.method" $value }}}{{ end }}
