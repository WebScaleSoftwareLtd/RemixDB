// This file is automatically generated by RemixDB. Do not edit.

package {{ Variable "package" }}

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"{{ if HasBigInt . }}
	"math/big"{{ end }}
	"net/http"
	"net/url"
	"path"{{ if HasTime . }}
	"time"{{ end }}
)

type readJoiner struct {
	index   int
	readers []io.Reader
}

func (r *readJoiner) Read(p []byte) (n int, err error) {
	if r.index >= len(r.readers) {
		return 0, io.EOF
	}

	for {
		// Get the current reader.
		reader := r.readers[r.index]

		// Read from the reader.
		x, err := reader.Read(p[n:])
		n += x
		if err == io.EOF {
			// If the reader is done, move to the next one.
			r.index++
			if r.index >= len(r.readers) {
				return n, io.EOF
			}
			continue
		}

		// If all the bytes were read or there was an error, return.
		if n == len(p) || err != nil {
			return n, err
		}

		// If the reader didn't return an error, but didn't read all the bytes,
		// move to the next reader.
		r.index++
		if r.index >= len(r.readers) {
			// If there are no more readers, return the number of bytes read.
			return n, nil
		}
	}
}

{{ range $key, $value := .Structs }}{{ if ne $value.Comment "" }}{{ range $i, $line := SplitLines $value.Comment }}// {{ if eq $i 0 }}{{ TitleCase $key }} {{ end }}{{ $line }}
{{ end }}{{ end }}struct {{ TitleCase $key }} {
{{ Subtemplate "golang.struct_values" $value }}}

{{ if $value.Exception }}// Error is used to return the error message.
func (e {{ TitleCase $key }}) Error() string {
{{ if HasKey $value.Fields "message" }}	return "{{ $key }}: " + fmt.Sprint(e.Message)
{{ else }}	return "{{ $key }}: " + {{ Subtemplate "golang.generic_error" $value.Fields }}
{{ end }}}

{{ end }}{{ end }}// Client is used to define the interface for the generated client.
type Client interface {
	// SetHTTPClient is used to set the HTTP client used by the RPC client. Please
	// note that the HTTP client must be safe for concurrent use, but this method
	// itself is not safe for concurrent use (so call it before you start using
	// the client).
	SetHTTPClient(client *http.Client){{ range $key, $value := .Methods }}

{{ if ne $value.Comment "" }}{{ range $i, $line := SplitLines $value.Comment }}	// {{ if eq $i 0 }}{{ TitleCase $key }} {{ end }}{{ $line }}
{{ end }}{{ end }}	{{ TitleCase $key }}(ctx context.Context{{ if ne $value.Input "" }}, {{ $value.InputName }} {{ if $value.InputOptional }}*{{ end }}{{ Switchfile "golang" $value.Input }}{{ end }}) {{ if eq $value.Output "" }}error{{ else }}({{ if $value.OutputOptional }}*{{ end }}{{ Switchfile "golang" $value.Output }}, error){{ end }}{{ end }}
}

// AuthenticationOptions is used to define the authentication options for the generated client.
type AuthenticationOptions struct {
{{ range $v := .AuthenticationKeys }}	{{ TitleCase $v }}{{ PadToMax .AuthenticationKeys $v }}string `json:"{{ $v }}"`
{{ end }}}{{ if HasCursor .Methods }}

{{ Subtemplate "golang.cursor" . }}{{ end }}

type client struct {
	authLine []byte
	url      string
	http     *http.Client
}

// ErrInvalidURLScheme is used when the URL scheme is not supported.
var ErrInvalidURLScheme = fmt.Errorf("invalid URL scheme")

// NewClient is used to create a new client.
func NewClient(url string, auth AuthenticationOptions) (Client, error) {
	u, err := url.Parse(url)
	if err != nil {
		return nil, err
	}

	if u.Scheme != "http" && u.Scheme != "https" {
		return nil, ErrInvalidURLScheme
	}

	b, _ := json.Marshal(auth)
	return &client{
		authLine: append(b, '\n'),
		url:      url,
	}, nil
}

func (c *client) SetHTTPClient(client *http.Client) {
	c.http = client
}

// ServerError is used to represent a server error.
type ServerError struct {
	// StatusCode is the HTTP status code.
	StatusCode int `json:"status_code"`

	// Code is the error code.
	Code string `json:"code"`

	// Message is the error message.
	Message string `json:"message"`
}

// Error is used to return the error message.
func (e ServerError) Error() string {
	return e.Code + ": " + e.Message
}

type httpSwitching struct {
	resp *http.Response
}

func (h httpSwitching) Read(p []byte) (n int, err error) {
	return 0, io.EOF
}

type serverError struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

func (c *client) do(
	ctx context.Context, methodName, schemaHash string,
	input []byte,
) (io.Reader, error) {
	u, err := url.Parse(c.url)
	if err != nil {
		return nil, err
	}
	u.Path = path.Join(u.Path, "rpc", methodName)

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, u.String(), &readJoiner{
		readers: []io.Reader{
			bytes.NewReader(c.authLine),
			bytes.NewReader(input),
		},
	})
	if err != nil {
		return nil, err
	}
	req.Header.Set("X-RemixDB-Schema-Hash", schemaHash)
	req.Header.Set("X-RemixDB-Socket-Reconnect", "false")
	req.Header.Set("Content-Type", "application/remixdb-rpc-mixed")

	httpClient := c.http
	if httpClient == nil {
		httpClient = http.DefaultClient
	}
	resp, err := httpClient.Do(req)
	if err != nil {
		return nil, err
	}

	if resp.Header.Get("X-Is-RemixDB") != "true" {
		_ = resp.Body.Close()
		return nil, ServerError{
			StatusCode: resp.StatusCode,
			Code:       "response_is_not_remixdb",
			Message:    "The response does not appear to be from RemixDB. Does your reverse proxy let through the X-Is-RemixDB header?",
		}
	}

	switch resp.StatusCode {
	case http.StatusOK:
		return resp.Body, nil
	case http.StatusSwitchingProtocols:
		return httpSwitching{resp: resp}, nil
	}

	switch customException := resp.Header.Get("X-RemixDB-Exception") {
	case "":
		// Do nothing.{{ range $key, $value := .Structs }}{{ if $value.Exception }}
	case "{{ $key }}":
		var e {{ TitleCase $key }}
		defer resp.Body.Close()
		if err := json.NewDecoder(resp.Body).Decode(&e); err != nil {
			return nil, ServerError{
				StatusCode: resp.StatusCode,
				Code:       "invalid_response",
				Message:    "The response could not be decoded.",
			}
		}
		return nil, e
{{ end }}{{ end }}	default:
		_ = resp.Body.Close()
		return nil, ServerError{
			StatusCode: resp.StatusCode,
			Code:       "exception_not_supported",
			Message:    "The server returned an exception, but this client does not support the exception specified.",
		}
	}

	var e serverError
	defer resp.Body.Close()
	if err := json.NewDecoder(resp.Body).Decode(&e); err != nil {
		return nil, ServerError{
			StatusCode: resp.StatusCode,
			Code:       "invalid_response",
			Message:    "The response could not be decoded.",
		}
	}

	return nil, ServerError{
		StatusCode: resp.StatusCode,
		Code:       e.Code,
		Message:    e.Message,
	}
}{{ range $key, $value := .Methods }}

func (c *client) {{ TitleCase $key }}(ctx context.Context{{ if ne $value.Input "" }}, {{ $value.InputName }} {{ if $value.InputOptional }}*{{ end }}{{ Switchfile "golang" $value.Input }}{{ end }}) {{ if eq $value.Output "" }}error{{ else }}({{ if $value.OutputOptional }}*{{ end }}{{ Switchfile "golang" $value.Output }}, error){{ end }} {
{{ Subtemplate "golang.method" $value }}}{{ end }}
