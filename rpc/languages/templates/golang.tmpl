// This file is automatically generated by RemixDB. Do not edit.

package {{ Variable "package" }}

import (
	"bytes"
	"context"
	"encoding/binary"
	"encoding/json"
	"fmt"
	"io"
	"math"{{ if HasBigInt . }}
	"math/big"{{ end }}
	"net/http"
	"net/url"
	"path"{{ if HasTime . }}
	"time"{{ end }}{{ if HasCursor . }}

	"nhooyr.io/websocket"{{ end }}
)

// Make sure this is always imported since it is used in a lot of places,
// but we do not want to break code if this is a edgecase file.
var (
	_ = binary.LittleEndian
	_ = math.E
)

type readJoiner struct {
	index   int
	readers []io.Reader
}

func (r *readJoiner) Read(p []byte) (n int, err error) {
	if r.index >= len(r.readers) {
		return 0, io.EOF
	}

	for {
		// Get the current reader.
		reader := r.readers[r.index]

		// Read from the reader.
		x, err := reader.Read(p[n:])
		n += x
		if err == io.EOF {
			// If the reader is done, move to the next one.
			r.index++
			if r.index >= len(r.readers) {
				return n, io.EOF
			}
			continue
		}

		// If all the bytes were read or there was an error, return.
		if n == len(p) || err != nil {
			return n, err
		}

		// If the reader didn't return an error, but didn't read all the bytes,
		// move to the next reader.
		r.index++
		if r.index >= len(r.readers) {
			// If there are no more readers, return the number of bytes read.
			return n, nil
		}
	}
}

{{ Static "golang.byte_slice_maker" }}
{{ range $key, $value := .Structs }}{{ if ne $value.Comment "" }}{{ range $i, $line := SplitLines $value.Comment }}// {{ if eq $i 0 }}{{ TitleCase $key }} {{ end }}{{ $line }}
{{ end }}{{ end }}type {{ TitleCase $key }} struct{{ if ne (len .Fields) 0 }} {{ end }}{{ `{` }}{{ Subtemplate "golang.struct_fields" $value }}}

{{ if $value.Exception }}// Error is used to return the error message.
func (e {{ TitleCase $key }}) Error() string {
{{ if HasKey $value.Fields "message" }}	return "{{ $key }}: " + fmt.Sprint(e.Message)
{{ else }}	return "{{ $key }}: " + {{ Subtemplate "golang.generic_error" $value.Fields }}
{{ end }}}

{{ end }}{{ end }}// Client is used to define the interface for the generated client.
type Client interface {
	// SetHTTPClient is used to set the HTTP client used by the RPC client. Please
	// note that the HTTP client must be safe for concurrent use, but this method
	// itself is not safe for concurrent use (so call it before you start using
	// the client).
	SetHTTPClient(client *http.Client){{ range $key, $value := .Methods }}

{{ if ne $value.Comment "" }}{{ range $i, $line := SplitLines $value.Comment }}	// {{ if eq $i 0 }}{{ TitleCase $key }} {{ end }}{{ $line }}
{{ end }}{{ end }}	{{ TitleCase $key }}{{ Subtemplate "golang.method_sig" $value }}{{ end }}
}

// AuthenticationOptions is used to define the authentication options for the generated client.
type AuthenticationOptions struct {
{{ $keys := .AuthenticationKeys }}{{ range $v := $keys }}	{{ TitleCase $v }}{{ PadToMax $keys $v }}string `json:"{{ $v }}"`
{{ end }}}

type client struct {
	authLine []byte
	url      string
	http     *http.Client
}

// ErrInvalidURLScheme is used when the URL scheme is not supported.
var ErrInvalidURLScheme = fmt.Errorf("invalid URL scheme")

// NewClient is used to create a new client.
func NewClient(urlString string, auth AuthenticationOptions) (Client, error) {
	u, err := url.Parse(urlString)
	if err != nil {
		return nil, err
	}

	if u.Scheme != "http" && u.Scheme != "https" {
		return nil, ErrInvalidURLScheme
	}

	b, _ := json.Marshal(auth)
	return &client{
		authLine: append(b, '\n'),
		url:      urlString,
	}, nil
}

func (c *client) SetHTTPClient(client *http.Client) {
	c.http = client
}

func parseCustomException(statusCode int, key string, body io.ReadCloser) error {
	switch key {
{{ range $key, $value := .Structs }}{{ if $value.Exception }}	case "{{ $key }}":
		var e {{ TitleCase $key }}
		defer body.Close()
		if err := json.NewDecoder(body).Decode(&e); err != nil {
			return ServerError{
				StatusCode: statusCode,
				Code:       "invalid_response",
				Message:    "The response could not be decoded.",
			}
		}
		return e
{{ end }}{{ end }}	}
	return nil
}

// ServerError is used to represent a server error.
type ServerError struct {
	// StatusCode is the HTTP status code. This is not present for cursors.
	StatusCode int `json:"status_code"`

	// Code is the error code.
	Code string `json:"code"`

	// Message is the error message.
	Message string `json:"message"`
}

// Error is used to return the error message.
func (e ServerError) Error() string {
	return e.Code + ": " + e.Message
}{{ if HasCursor . }}

{{ Static "golang.cursor" }}{{ else }}
{{ end }}
func remixdbInternalUnexpectedPacket(typeWanted string, packetByte byte) error {
	var packetByteS string
	switch packetByte {
	case 0x00:
		packetByteS = "null"
	case 0x01:
		packetByteS = "false (bool)"
	case 0x02:
		packetByteS = "true (bool)"
	case 0x03, 0x05:
		packetByteS = "bytes"
	case 0x04, 0x06:
		packetByteS = "string"
	case 0x07:
		packetByteS = "array"
	case 0x08:
		packetByteS = "map"
	case 0x09:
		packetByteS = "struct"
	case 0x0a, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
		0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20,
		0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29,
		0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f:
		packetByteS = "integer"
	case 0x0b, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
		0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70,
		0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
		0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f:
		packetByteS = "float"
	case 0x0c:
		packetByteS = "timestamp"
	case 0x0d, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
		0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50,
		0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
		0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f:
		packetByteS = "big integer"
	case 0x0e, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
		0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f:
		packetByteS = "uint"
	default:
		packetByteS = "unknown"
	}

	errMsg := "expected packet of type " + typeWanted + ", got " + packetByteS
	return ServerError{
		Code:    "unexpected_packet",
		Message: errMsg,
	}
}

type serverError struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

func (c *client) do(ctx context.Context, methodName, schemaHash string, input []byte) ([]byte, error) {
	u, err := url.Parse(c.url)
	if err != nil {
		return nil, err
	}
	u.Path = path.Join(u.Path, "rpc", methodName)

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, u.String(), &readJoiner{
		readers: []io.Reader{
			bytes.NewReader(c.authLine),
			bytes.NewReader(input),
		},
	})
	if err != nil {
		return nil, err
	}
	req.Header.Set("X-RemixDB-Schema-Hash", schemaHash)
	req.Header.Set("Content-Type", "application/x-remixdb-rpc-mixed")

	httpClient := c.http
	if httpClient == nil {
		httpClient = http.DefaultClient
	}
	resp, err := httpClient.Do(req)
	if err != nil {
		return nil, err
	}

	if resp.Header.Get("X-Is-RemixDB") != "true" {
		_ = resp.Body.Close()
		return nil, ServerError{
			StatusCode: resp.StatusCode,
			Code:       "response_is_not_remixdb",
			Message:    "The response does not appear to be from RemixDB. Does your reverse proxy let through the X-Is-RemixDB header?",
		}
	}

	switch resp.StatusCode {
	case http.StatusOK, http.StatusNoContent:
		return io.ReadAll(resp.Body)
	}

	e := resp.Header.Get("X-RemixDB-Exception")
	switch e {
	case "":
		// Do nothing.
	default:
		if err := parseCustomException(resp.StatusCode, e, resp.Body); err != nil {
			return nil, err
		}
		_ = resp.Body.Close()
		return nil, ServerError{
			StatusCode: resp.StatusCode,
			Code:       "exception_not_supported",
			Message:    "The server returned an exception, but this client does not support the exception specified.",
		}
	}

	var sErr serverError
	defer resp.Body.Close()
	if err := json.NewDecoder(resp.Body).Decode(&sErr); err != nil {
		return nil, ServerError{
			StatusCode: resp.StatusCode,
			Code:       "invalid_response",
			Message:    "The response could not be decoded.",
		}
	}

	return nil, ServerError{
		StatusCode: resp.StatusCode,
		Code:       sErr.Code,
		Message:    sErr.Message,
	}
}{{ range $key, $value := .Methods }}

func (c *client) {{ TitleCase $key }}{{ Subtemplate "golang.method_sig" $value }} {
{{ Subtemplate "golang.method" (KeyAndValue $key $value) | Tabify 1 }}}{{ end }}
