// This file is automatically generated by RemixDB. Do not edit.

package test

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"

	"nhooyr.io/websocket"
)

type readJoiner struct {
	index   int
	readers []io.Reader
}

func (r *readJoiner) Read(p []byte) (n int, err error) {
	if r.index >= len(r.readers) {
		return 0, io.EOF
	}

	for {
		// Get the current reader.
		reader := r.readers[r.index]

		// Read from the reader.
		x, err := reader.Read(p[n:])
		n += x
		if err == io.EOF {
			// If the reader is done, move to the next one.
			r.index++
			if r.index >= len(r.readers) {
				return n, io.EOF
			}
			continue
		}

		// If all the bytes were read or there was an error, return.
		if n == len(p) || err != nil {
			return n, err
		}

		// If the reader didn't return an error, but didn't read all the bytes,
		// move to the next reader.
		r.index++
		if r.index >= len(r.readers) {
			// If there are no more readers, return the number of bytes read.
			return n, nil
		}
	}
}

type byteSliceAddition struct {
	next *byteSliceAddition
	b    *byte
	sl   []byte
	u16  *uint16
	u32  *uint32
	u64  *uint64
	s    string
}

type byteSliceMaker struct {
	len   int
	start *byteSliceAddition
	end   *byteSliceAddition
}

func (b *byteSliceMaker) newAddition() *byteSliceAddition {
	a := &byteSliceAddition{}
	if b.start == nil {
		b.start = a
		b.end = a
	} else {
		b.end.next = a
		b.end = a
	}
	return a
}

func (b *byteSliceMaker) AddByte(x byte) {
	a := b.newAddition()
	a.b = &x
	b.len++
}

func (b *byteSliceMaker) AddByteSlice(x []byte) {
	a := b.newAddition()
	a.sl = x
	b.len += len(x)
}

func (b *byteSliceMaker) AddUint16(x uint16) {
	a := b.newAddition()
	a.u16 = &x
	b.len += 2
}

func (b *byteSliceMaker) AddUint32(x uint32) {
	a := b.newAddition()
	a.u32 = &x
	b.len += 4
}

func (b *byteSliceMaker) AddUint64(x uint64) {
	a := b.newAddition()
	a.u64 = &x
	b.len += 8
}

func (b *byteSliceMaker) AddString(x string) {
	a := b.newAddition()
	a.s = x
	b.len += len(x)
}

func (b *byteSliceMaker) Make() []byte {
	sl := make([]byte, b.len)
	view := sl

	for x := b.start; x != nil; x = x.next {
		switch {
		case x.b != nil:
			view[0] = *x.b
			view = view[1:]
		case x.sl != nil:
			copy(view, x.sl)
			view = view[len(x.sl):]
		case x.u16 != nil:
			binary.LittleEndian.PutUint16(view, *x.u16)
			view = view[2:]
		case x.u32 != nil:
			binary.LittleEndian.PutUint32(view, *x.u32)
			view = view[4:]
		case x.u64 != nil:
			binary.LittleEndian.PutUint64(view, *x.u64)
			view = view[8:]
		default:
			copy(view, x.s)
			view = view[len(x.s):]
		}
	}

	return sl
}

// ErrorWithAllFields used to test a error with all fields
type ErrorWithAllFields struct {
	// Field used to test a field
	Field string `json:"field"`

	// Field2 used to test a field
	Field2 string `json:"field2"`
}

// Error is used to return the error message.
func (e ErrorWithAllFields) Error() string {
	return "ErrorWithAllFields: " + fmt.Sprint("{", "Field =", e.Field, "Field2 =", e.Field2, "}")
}

// ErrorWithMessageField used to test a error with a message field
type ErrorWithMessageField struct {
	// Field used to test a field
	Field *string `json:"field"`

	// Message used to test a message field
	Message string `json:"message"`
}

// Error is used to return the error message.
func (e ErrorWithMessageField) Error() string {
	return "ErrorWithMessageField: " + fmt.Sprint(e.Message)
}

// OneField used to test a single field
type OneField struct {
	// Field used to test a field
	Field string `json:"field"`
}

// Client is used to define the interface for the generated client.
type Client interface {
	// SetHTTPClient is used to set the HTTP client used by the RPC client. Please
	// note that the HTTP client must be safe for concurrent use, but this method
	// itself is not safe for concurrent use (so call it before you start using
	// the client).
	SetHTTPClient(client *http.Client)

	// AllVoid used to test all void
	AllVoid(ctx context.Context) error

	// Cursor used to test a cursor
	Cursor(ctx context.Context) (Cursor[string], error)

	NoComment(ctx context.Context, NoCommentInput string) (string, error)

	// VoidInput used to test a void input
	VoidInput(ctx context.Context) (string, error)

	// VoidOutput used to test a void output
	VoidOutput(ctx context.Context, VoidOutputInput string) error
}

// AuthenticationOptions is used to define the authentication options for the generated client.
type AuthenticationOptions struct {
	LongKey string `json:"long_key"`
	Key2    string `json:"key2"`
}

type client struct {
	authLine []byte
	url      string
	http     *http.Client
}

// ErrInvalidURLScheme is used when the URL scheme is not supported.
var ErrInvalidURLScheme = fmt.Errorf("invalid URL scheme")

// NewClient is used to create a new client.
func NewClient(urlString string, auth AuthenticationOptions) (Client, error) {
	u, err := url.Parse(urlString)
	if err != nil {
		return nil, err
	}

	if u.Scheme != "http" && u.Scheme != "https" {
		return nil, ErrInvalidURLScheme
	}

	b, _ := json.Marshal(auth)
	return &client{
		authLine: append(b, '\n'),
		url:      urlString,
	}, nil
}

func (c *client) SetHTTPClient(client *http.Client) {
	c.http = client
}

func parseCustomException(key string, body io.Reader) error {
	switch key {
	case "ErrorWithAllFields":
		var e ErrorWithAllFields
		defer resp.Body.Close()
		if err := json.NewDecoder(resp.Body).Decode(&e); err != nil {
			return nil, ServerError{
				StatusCode: resp.StatusCode,
				Code:       "invalid_response",
				Message:    "The response could not be decoded.",
			}
		}
		return nil, e
	case "ErrorWithMessageField":
		var e ErrorWithMessageField
		defer resp.Body.Close()
		if err := json.NewDecoder(resp.Body).Decode(&e); err != nil {
			return nil, ServerError{
				StatusCode: resp.StatusCode,
				Code:       "invalid_response",
				Message:    "The response could not be decoded.",
			}
		}
		return nil, e
	}
	return nil
}

// ServerError is used to represent a server error.
type ServerError struct {
	// StatusCode is the HTTP status code. This is not present for cursors.
	StatusCode int `json:"status_code"`

	// Code is the error code.
	Code string `json:"code"`

	// Message is the error message.
	Message string `json:"message"`
}

// Error is used to return the error message.
func (e ServerError) Error() string {
	return e.Code + ": " + e.Message
}

// Cursor is used to define the handler for a database cursor. The cursor logic is automatically
// injected if your schema includes a cursor within it.
type Cursor[T any] struct {
	transformer func([]byte) (T, error)
	conn        *websocket.Conn
}

// Close is used to close the cursor.
func (c Cursor[T]) Close() error {
	if c.conn == nil {
		return nil
	}
	return c.conn.CloseNow()
}

// Handles exceptions within cursor packets. Automatically injected if your structure has a cursor.
func handleExceptionPacket(msg []byte, mLen int) error {
	if 3 > mLen {
		goto malformedErr
	}
	isCustom := msg[0] == 1

	msg = msg[1:]
	exceptionNameLen := int(binary.LittleEndian.Uint16(msg))
	msg = msg[2:]
	if exceptionNameLen > len(msg) {
		goto malformedErr
	}

	code := string(msg[:exceptionNameLen])
	msg = msg[exceptionNameLen:]

	if isCustom {
		if err := parseCustomException(code, bytes.NewReader(msg)); err != nil {
			return err
		}
		return ServerError{
			Code:    "exception_not_supported",
			Message: "The server returned an exception, but this client does not support the exception specified.",
		}
	}

	return ServerError{
		Code:    code,
		Message: string(msg),
	}

malformedErr:
	return ServerError{
		Code:    "malformed_packet",
		Message: "The cursor response packet was malformed.",
	}
}

// Next is used to get the next cursor item.
func (c Cursor[T]) Next(ctx context.Context) (val T, err error) {
	if err = c.conn.Write(ctx, websocket.MessageBinary, []byte{1}); err != nil {
		return
	}
	var msg []byte
	if _, msg, err = c.conn.Read(ctx); err != nil {
		return
	}

	mLen := len(msg)
	if mLen >= 1 {
		switch status := msg[0] {
		case 2:
			return c.transformer(msg[1:])
		case 3:
			err = io.EOF
			return
		}
	}

	err = handleExceptionPacket(msg, mLen)
}

// Initializes the cursor. Automatically injected when a cursor is used.
func initCursor[T any](
	c *client, ctx context.Context, methodName, schemaHash string, input []byte,
	transformer func([]byte) (T, error),
) (Cursor[T], error) {
	opts := &websocket.DialOptions{HTTPClient: c.http}

	u, err := url.Parse(c.url)
	if err != nil {
		return nil, err
	}
	u.Path = path.Join(u.Path, "rpc")

	ws, _, err := websocket.Dial(ctx, u.String(), opts)
	if err != nil {
		return Cursor[T]{}, err
	}

	methodLen := 2 + len(methodName)
	schemaLen := 2 + len(schemaHash)
	authLineLen := len(c.authLine)
	b := make([]byte, methodLen + schemaLen + authLineLen + len(input))

	binary.LittleEndian.PutUint16(b, uint16(len(methodName)))
	copy(b[2:], methodName)

	view := b[methodLen:]
	binary.LittleEndian.PutUint16(view, uint16(len(schemaHash)))
	copy(view[2:], schemaHash)

	view = view[schemaLen:]
	copy(view, c.authLine)
	copy(view[authLineLen:], input)
	view = nil

	if err = ws.Write(ctx, websocket.MessageBinary, b); err != nil {
		return Cursor[T]{}, err
	}

	if _, b, err = ws.Read(ctx); err != nil {
		return Cursor[T]{}, err
	}

	bLen := len(b)
	if bLen == 1 && b[0] == 2 {
		return Cursor[T]{
			transformer: transformer,
			conn:        ws,
		}, nil
	}

	return Cursor[T]{}, handleExceptionPacket(b, bLen)
}

type serverError struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

func (c *client) do(ctx context.Context, methodName, schemaHash string, input []byte) (io.Reader, error) {
	u, err := url.Parse(c.url)
	if err != nil {
		return nil, err
	}
	u.Path = path.Join(u.Path, "rpc", methodName)

	req, err := http.NewRequestWithContext(ctx, http.MethodPost, u.String(), &readJoiner{
		readers: []io.Reader{
			bytes.NewReader(c.authLine),
			bytes.NewReader(input),
		},
	})
	if err != nil {
		return nil, err
	}
	req.Header.Set("X-RemixDB-Schema-Hash", schemaHash)
	req.Header.Set("Content-Type", "application/x-remixdb-rpc-mixed")

	httpClient := c.http
	if httpClient == nil {
		httpClient = http.DefaultClient
	}
	resp, err := httpClient.Do(req)
	if err != nil {
		return nil, err
	}

	if resp.Header.Get("X-Is-RemixDB") != "true" {
		_ = resp.Body.Close()
		return nil, ServerError{
			StatusCode: resp.StatusCode,
			Code:       "response_is_not_remixdb",
			Message:    "The response does not appear to be from RemixDB. Does your reverse proxy let through the X-Is-RemixDB header?",
		}
	}

	switch resp.StatusCode {
	case http.StatusOK, http.StatusNoContent:
		return resp.Body, nil
	}

	switch e := resp.Header.Get("X-RemixDB-Exception") {
	case "":
		// Do nothing.
	default:
		if err := parseCustomException(e, resp.Body); err != nil {
			return nil, err
		}
		_ = resp.Body.Close()
		return nil, ServerError{
			StatusCode: resp.StatusCode,
			Code:       "exception_not_supported",
			Message:    "The server returned an exception, but this client does not support the exception specified.",
		}
	}

	var e serverError
	defer resp.Body.Close()
	if err := json.NewDecoder(resp.Body).Decode(&e); err != nil {
		return nil, ServerError{
			StatusCode: resp.StatusCode,
			Code:       "invalid_response",
			Message:    "The response could not be decoded.",
		}
	}

	return nil, ServerError{
		StatusCode: resp.StatusCode,
		Code:       e.Code,
		Message:    e.Message,
	}
}

func (c *client) AllVoid(ctx context.Context) error {
	remixdbInternalSliceMaker := byteSliceMaker{}

	r, err := c.do(ctx, "AllVoid", "", remixdbInternalSliceMaker.Make())
	if err != nil {
		return err
	}

	_ = r.Close()
	return nil
}

func (c *client) Cursor(ctx context.Context) (Cursor[string], error) {
	remixdbInternalSliceMaker := byteSliceMaker{}
	remixdbInternalError := func(e error) (_ string, err error) {
		err = e
		return
	}

	return initCursor(c, ctx, "Cursor", "", remixdbInternalSliceMaker.Make(), func(b []byte) (string, error) {
		// TODO: Handle outputs
	})
}

func (c *client) NoComment(ctx context.Context, NoCommentInput string) (string, error) {
	remixdbInternalSliceMaker := byteSliceMaker{}
	remixdbInternalError := func(e error) (_ string, err error) {
		err = e
		return
	}

	// TODO: Handle inputs

	r, err := c.do(ctx, "NoComment", "", remixdbInternalSliceMaker.Make())
	if err != nil {
		return remixdbInternalError(err)
	}

	// TODO: Handle outputs
}

func (c *client) VoidInput(ctx context.Context) (string, error) {
	remixdbInternalSliceMaker := byteSliceMaker{}
	remixdbInternalError := func(e error) (_ string, err error) {
		err = e
		return
	}

	r, err := c.do(ctx, "VoidInput", "", remixdbInternalSliceMaker.Make())
	if err != nil {
		return remixdbInternalError(err)
	}

	// TODO: Handle outputs
}

func (c *client) VoidOutput(ctx context.Context, VoidOutputInput string) error {
	remixdbInternalSliceMaker := byteSliceMaker{}

	// TODO: Handle inputs

	r, err := c.do(ctx, "VoidOutput", "", remixdbInternalSliceMaker.Make())
	if err != nil {
		return err
	}

	_ = r.Close()
	return nil
}
