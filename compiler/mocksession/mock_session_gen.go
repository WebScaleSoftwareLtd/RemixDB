// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocksession

import (
	"remixdb.io/ast"
	"remixdb.io/engine"
	"sync"
)

// Ensure, that SessionMock does implement engine.Session.
// If this is not the case, regenerate this file with moq.
var _ engine.Session = &SessionMock{}

// SessionMock is a mock implementation of engine.Session.
//
//	func TestSomethingThatUsesSession(t *testing.T) {
//
//		// make and configure a mocked engine.Session
//		mockedSession := &SessionMock{
//			CloseFunc: func() error {
//				panic("mock out the Close method")
//			},
//			CommitFunc: func() error {
//				panic("mock out the Commit method")
//			},
//			ContractTombstonesFunc: func() ([]*ast.ContractToken, error) {
//				panic("mock out the ContractTombstones method")
//			},
//			ContractsFunc: func() ([]*ast.ContractToken, error) {
//				panic("mock out the Contracts method")
//			},
//			DeleteContractByKeyFunc: func(key string) error {
//				panic("mock out the DeleteContractByKey method")
//			},
//			GetContractByKeyFunc: func(key string) (*ast.ContractToken, error) {
//				panic("mock out the GetContractByKey method")
//			},
//			RollbackFunc: func() error {
//				panic("mock out the Rollback method")
//			},
//			WriteContractFunc: func(contract *ast.ContractToken) error {
//				panic("mock out the WriteContract method")
//			},
//		}
//
//		// use mockedSession in code that requires engine.Session
//		// and then make assertions.
//
//	}
type SessionMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func() error

	// CommitFunc mocks the Commit method.
	CommitFunc func() error

	// ContractTombstonesFunc mocks the ContractTombstones method.
	ContractTombstonesFunc func() ([]*ast.ContractToken, error)

	// ContractsFunc mocks the Contracts method.
	ContractsFunc func() ([]*ast.ContractToken, error)

	// DeleteContractByKeyFunc mocks the DeleteContractByKey method.
	DeleteContractByKeyFunc func(key string) error

	// GetContractByKeyFunc mocks the GetContractByKey method.
	GetContractByKeyFunc func(key string) (*ast.ContractToken, error)

	// RollbackFunc mocks the Rollback method.
	RollbackFunc func() error

	// WriteContractFunc mocks the WriteContract method.
	WriteContractFunc func(contract *ast.ContractToken) error

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Commit holds details about calls to the Commit method.
		Commit []struct {
		}
		// ContractTombstones holds details about calls to the ContractTombstones method.
		ContractTombstones []struct {
		}
		// Contracts holds details about calls to the Contracts method.
		Contracts []struct {
		}
		// DeleteContractByKey holds details about calls to the DeleteContractByKey method.
		DeleteContractByKey []struct {
			// Key is the key argument value.
			Key string
		}
		// GetContractByKey holds details about calls to the GetContractByKey method.
		GetContractByKey []struct {
			// Key is the key argument value.
			Key string
		}
		// Rollback holds details about calls to the Rollback method.
		Rollback []struct {
		}
		// WriteContract holds details about calls to the WriteContract method.
		WriteContract []struct {
			// Contract is the contract argument value.
			Contract *ast.ContractToken
		}
	}
	lockClose               sync.RWMutex
	lockCommit              sync.RWMutex
	lockContractTombstones  sync.RWMutex
	lockContracts           sync.RWMutex
	lockDeleteContractByKey sync.RWMutex
	lockGetContractByKey    sync.RWMutex
	lockRollback            sync.RWMutex
	lockWriteContract       sync.RWMutex
}

// Close calls CloseFunc.
func (mock *SessionMock) Close() error {
	if mock.CloseFunc == nil {
		panic("SessionMock.CloseFunc: method is nil but Session.Close was just called")
	}
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	return mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedSession.CloseCalls())
func (mock *SessionMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Commit calls CommitFunc.
func (mock *SessionMock) Commit() error {
	if mock.CommitFunc == nil {
		panic("SessionMock.CommitFunc: method is nil but Session.Commit was just called")
	}
	callInfo := struct {
	}{}
	mock.lockCommit.Lock()
	mock.calls.Commit = append(mock.calls.Commit, callInfo)
	mock.lockCommit.Unlock()
	return mock.CommitFunc()
}

// CommitCalls gets all the calls that were made to Commit.
// Check the length with:
//
//	len(mockedSession.CommitCalls())
func (mock *SessionMock) CommitCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockCommit.RLock()
	calls = mock.calls.Commit
	mock.lockCommit.RUnlock()
	return calls
}

// ContractTombstones calls ContractTombstonesFunc.
func (mock *SessionMock) ContractTombstones() ([]*ast.ContractToken, error) {
	if mock.ContractTombstonesFunc == nil {
		panic("SessionMock.ContractTombstonesFunc: method is nil but Session.ContractTombstones was just called")
	}
	callInfo := struct {
	}{}
	mock.lockContractTombstones.Lock()
	mock.calls.ContractTombstones = append(mock.calls.ContractTombstones, callInfo)
	mock.lockContractTombstones.Unlock()
	return mock.ContractTombstonesFunc()
}

// ContractTombstonesCalls gets all the calls that were made to ContractTombstones.
// Check the length with:
//
//	len(mockedSession.ContractTombstonesCalls())
func (mock *SessionMock) ContractTombstonesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockContractTombstones.RLock()
	calls = mock.calls.ContractTombstones
	mock.lockContractTombstones.RUnlock()
	return calls
}

// Contracts calls ContractsFunc.
func (mock *SessionMock) Contracts() ([]*ast.ContractToken, error) {
	if mock.ContractsFunc == nil {
		panic("SessionMock.ContractsFunc: method is nil but Session.Contracts was just called")
	}
	callInfo := struct {
	}{}
	mock.lockContracts.Lock()
	mock.calls.Contracts = append(mock.calls.Contracts, callInfo)
	mock.lockContracts.Unlock()
	return mock.ContractsFunc()
}

// ContractsCalls gets all the calls that were made to Contracts.
// Check the length with:
//
//	len(mockedSession.ContractsCalls())
func (mock *SessionMock) ContractsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockContracts.RLock()
	calls = mock.calls.Contracts
	mock.lockContracts.RUnlock()
	return calls
}

// DeleteContractByKey calls DeleteContractByKeyFunc.
func (mock *SessionMock) DeleteContractByKey(key string) error {
	if mock.DeleteContractByKeyFunc == nil {
		panic("SessionMock.DeleteContractByKeyFunc: method is nil but Session.DeleteContractByKey was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	mock.lockDeleteContractByKey.Lock()
	mock.calls.DeleteContractByKey = append(mock.calls.DeleteContractByKey, callInfo)
	mock.lockDeleteContractByKey.Unlock()
	return mock.DeleteContractByKeyFunc(key)
}

// DeleteContractByKeyCalls gets all the calls that were made to DeleteContractByKey.
// Check the length with:
//
//	len(mockedSession.DeleteContractByKeyCalls())
func (mock *SessionMock) DeleteContractByKeyCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	mock.lockDeleteContractByKey.RLock()
	calls = mock.calls.DeleteContractByKey
	mock.lockDeleteContractByKey.RUnlock()
	return calls
}

// GetContractByKey calls GetContractByKeyFunc.
func (mock *SessionMock) GetContractByKey(key string) (*ast.ContractToken, error) {
	if mock.GetContractByKeyFunc == nil {
		panic("SessionMock.GetContractByKeyFunc: method is nil but Session.GetContractByKey was just called")
	}
	callInfo := struct {
		Key string
	}{
		Key: key,
	}
	mock.lockGetContractByKey.Lock()
	mock.calls.GetContractByKey = append(mock.calls.GetContractByKey, callInfo)
	mock.lockGetContractByKey.Unlock()
	return mock.GetContractByKeyFunc(key)
}

// GetContractByKeyCalls gets all the calls that were made to GetContractByKey.
// Check the length with:
//
//	len(mockedSession.GetContractByKeyCalls())
func (mock *SessionMock) GetContractByKeyCalls() []struct {
	Key string
} {
	var calls []struct {
		Key string
	}
	mock.lockGetContractByKey.RLock()
	calls = mock.calls.GetContractByKey
	mock.lockGetContractByKey.RUnlock()
	return calls
}

// Rollback calls RollbackFunc.
func (mock *SessionMock) Rollback() error {
	if mock.RollbackFunc == nil {
		panic("SessionMock.RollbackFunc: method is nil but Session.Rollback was just called")
	}
	callInfo := struct {
	}{}
	mock.lockRollback.Lock()
	mock.calls.Rollback = append(mock.calls.Rollback, callInfo)
	mock.lockRollback.Unlock()
	return mock.RollbackFunc()
}

// RollbackCalls gets all the calls that were made to Rollback.
// Check the length with:
//
//	len(mockedSession.RollbackCalls())
func (mock *SessionMock) RollbackCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockRollback.RLock()
	calls = mock.calls.Rollback
	mock.lockRollback.RUnlock()
	return calls
}

// WriteContract calls WriteContractFunc.
func (mock *SessionMock) WriteContract(contract *ast.ContractToken) error {
	if mock.WriteContractFunc == nil {
		panic("SessionMock.WriteContractFunc: method is nil but Session.WriteContract was just called")
	}
	callInfo := struct {
		Contract *ast.ContractToken
	}{
		Contract: contract,
	}
	mock.lockWriteContract.Lock()
	mock.calls.WriteContract = append(mock.calls.WriteContract, callInfo)
	mock.lockWriteContract.Unlock()
	return mock.WriteContractFunc(contract)
}

// WriteContractCalls gets all the calls that were made to WriteContract.
// Check the length with:
//
//	len(mockedSession.WriteContractCalls())
func (mock *SessionMock) WriteContractCalls() []struct {
	Contract *ast.ContractToken
} {
	var calls []struct {
		Contract *ast.ContractToken
	}
	mock.lockWriteContract.RLock()
	calls = mock.calls.WriteContract
	mock.lockWriteContract.RUnlock()
	return calls
}
